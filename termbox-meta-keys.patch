diff --git a/src/demo/keyboard.c b/src/demo/keyboard.c
index e2164d3..0666627 100644
--- a/src/demo/keyboard.c
+++ b/src/demo/keyboard.c
@@ -614,8 +614,7 @@ void pretty_print_press(struct tb_event *ev)
 	printf_tb(60, 21, TB_CYAN  , TB_DEFAULT, "octal:   0%o", ev->ch);
 	printf_tb(60, 22, TB_RED   , TB_DEFAULT, "string:  %s", buf);
 
-	printf_tb(54, 18, TB_WHITE, TB_DEFAULT, "Modifier: %s",
-			(ev->mod) ? "TB_MOD_ALT" : "none");
+	printf_tb(54, 18, TB_WHITE, TB_DEFAULT, "Meta/mod: %d/%s", ev->meta, (ev->mod) ? "TB_MOD_ALT" : "none");
 
 }
 
diff --git a/src/input.inl b/src/input.inl
index a4dbfca..8c81146 100644
--- a/src/input.inl
+++ b/src/input.inl
@@ -1,3 +1,5 @@
+extern char * term_name;
+
 // if s1 starts with s2 returns true, else false
 // len is the length of s1
 // s2 should be null-terminated
@@ -90,7 +92,7 @@ static int parse_mouse_event(struct tb_event *event, const char *buf, int len) {
 		n1 = strtoul(&buf[starti], NULL, 10);
 		n2 = strtoul(&buf[s1 + 1], NULL, 10);
 		n3 = strtoul(&buf[s2 + 1], NULL, 10);
-		
+
 		if (isU)
 			n1 -= 32;
 
@@ -137,6 +139,140 @@ static int parse_mouse_event(struct tb_event *event, const char *buf, int len) {
 	return 0;
 }
 
+// #define DEBUGGING 1
+// function ported from tcolar's termbox-go fork:
+// https://github.com/tcolar/termbox-go/commit/8e386c1b6b783dee1904d688347e2d282450b8e7
+
+// example bufs:
+
+//       xterm:
+//        27, 91, 49, 59, 50, 65  --> shift + up arrow
+//        27, 91, 49, 59, 50, 66  --> shift + down arrow
+//       esc   [  1   ;   mod key
+
+//       urxvt:
+//        27  91  98 -13 -91, 126
+//        27  91  98 -95  40  127 <-- with URxvt.iso14755 = false
+//       esc mod key
+
+//       mrxvt:
+//        27, 91, 66, 59, 50, 66
+//        27, 91, 49, 59, 50, 66
+
+static bool parse_meta_key(struct tb_event *event, const char *buf, const char *key) {
+
+	int kl = strlen(key);
+
+#ifdef DEBUGGING
+	int i;
+	printf("\nbuf: %s --> ", ""); // buf);
+	for (i = 0; i < strlen(buf); i++)
+		printf("%d ", buf[i]);
+
+	printf("\nkey: %s --> ", ""); // key);
+	for (i = 0; i < strlen(key); i++)
+		printf("%d ", key[i]);
+#endif
+
+	if (strlen(buf) < kl+2) {
+		return false;
+	}
+
+	if (buf[0] != key[0] || buf[1] != key[1]) {
+		return false;
+	}
+
+	if (buf[kl-1] != 59) { // ';'
+		return false;
+	}
+
+	if (buf[kl] < 50 || buf[kl] > 57) { // 2 to 9 ASCII
+		return false;
+	}
+
+	if (buf[kl+1] != key[kl-1]) {
+		// printf("%d != %d\n", buf[kl+1], key[kl-1]);
+		return false;
+	}
+
+	event->ch = 0;
+	event->meta = buf[kl] - 48;
+
+	return true;
+}
+
+#define known_codes_length 28
+
+const char * known_codes[known_codes_length] = {
+	"\033[Z", // Shift+TAB
+	// "\033[2$", // Shift+Insert
+	"\033[3$", // Shift+Delete
+	"\033[5$", // Shift+PageUp
+	"\033[6$", // Shift+PageDown
+	"\033[7$", // Shift+Home
+	"\033[8$", // Shift+End
+  "\033[2^", // Ctrl+Insert
+	"\033[3^", // Ctrl+Delete
+	"\033[5^", // Ctrl+PageUp
+	"\033[6^", // Ctrl+PageDown
+	"\033[7^", // Ctrl+Home
+	"\033[8^", // Ctrl+End
+	"\033\033[a", // Alt+Shift+Up
+	"\033\033[b", // Alt+Shift+Down
+	"\033\033[c", // Alt+Shift+Left
+	"\033\033[d", // Alt+Shift+Right
+	"\033[a", // Shift+Up
+	"\033[b", // Shift+Down
+	"\033[c", // Shift+Left
+	"\033[d", // Shift+Right
+	"\033Oa", // Control+Up
+	"\033Ob", // Control+Down
+	"\033Oc", // Control+Left
+	"\033Od",  // Control+Right
+
+	"\033[5;5~", // Ctrl+PageUp
+	"\033[6;5~", // Ctrl+PageDown
+	"\033OH", // Ctrl+Home (xterm)
+	"\033OF", // Ctrl+End (xterm)
+};
+
+int known_codes_keys[known_codes_length][2] = {
+	// global, apparently
+	{ TB_KEY_TAB,          TB_META_SHIFT },
+
+	// urxvt
+	// { TB_KEY_INSERT,      TB_META_SHIFT },
+	{ TB_KEY_DELETE,      TB_META_SHIFT },
+	{ TB_KEY_PGUP,        TB_META_SHIFT },
+	{ TB_KEY_PGDN,        TB_META_SHIFT },
+	{ TB_KEY_HOME,        TB_META_SHIFT },
+	{ TB_KEY_END,         TB_META_SHIFT },
+	{ TB_KEY_INSERT,      TB_META_CTRL },
+	{ TB_KEY_DELETE,      TB_META_CTRL },
+	{ TB_KEY_PGUP,        TB_META_CTRL },
+	{ TB_KEY_PGDN,        TB_META_CTRL },
+	{ TB_KEY_HOME,        TB_META_CTRL },
+	{ TB_KEY_END,         TB_META_CTRL },
+	{ TB_KEY_ARROW_UP,    TB_META_ALTSHIFT },
+	{ TB_KEY_ARROW_DOWN,  TB_META_ALTSHIFT },
+	{ TB_KEY_ARROW_RIGHT, TB_META_ALTSHIFT },
+	{ TB_KEY_ARROW_LEFT,  TB_META_ALTSHIFT },
+	{ TB_KEY_ARROW_UP,    TB_META_SHIFT },
+	{ TB_KEY_ARROW_DOWN,  TB_META_SHIFT },
+	{ TB_KEY_ARROW_RIGHT, TB_META_SHIFT },
+	{ TB_KEY_ARROW_LEFT,  TB_META_SHIFT },
+	{ TB_KEY_ARROW_UP,    TB_META_CTRL  },
+	{ TB_KEY_ARROW_DOWN,  TB_META_CTRL  },
+	{ TB_KEY_ARROW_RIGHT, TB_META_CTRL  },
+	{ TB_KEY_ARROW_LEFT,  TB_META_CTRL  },
+
+	// xterm
+	{ TB_KEY_PGDN,        TB_META_CTRL },
+	{ TB_KEY_PGUP,        TB_META_CTRL },
+	{ TB_KEY_HOME,        TB_META_CTRL },
+	{ TB_KEY_END,         TB_META_CTRL }
+};
+
 // convert escape sequence to event, and return consumed bytes on success (failure == 0)
 static int parse_escape_seq(struct tb_event *event, const char *buf, int len)
 {
@@ -148,12 +284,76 @@ static int parse_escape_seq(struct tb_event *event, const char *buf, int len)
 	// it's pretty simple here, find 'starts_with' match and return
 	// success, else return failure
 	int i;
+
+	// if (strcmp(term_name, "xterm") != 0) {
+		for (i = 0; i < known_codes_length; i++) {
+			// printf("[%d] %d %d %d %d %d %d", len, buf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);
+			if (starts_with(buf, len, known_codes[i])) {
+				// printf(" ------ found: %d\n", i);
+				event->ch   = 0;
+				event->key  = known_codes_keys[i][0];
+				event->meta = known_codes_keys[i][1];
+				return strlen(known_codes[i]);
+			}
+		}
+	// }
+
+	char desc[20];
 	for (i = 0; keys[i]; i++) {
+
 		if (starts_with(buf, len, keys[i])) {
 			event->ch = 0;
 			event->key = 0xFFFF-i;
 			return strlen(keys[i]);
 		}
+
+		if (parse_meta_key(event, buf, keys[i])) {
+			event->key = 0xFFFF-i;
+			return strlen(keys[i]) + 2;
+		}
+
+		if (keys[i][1] == 79 || (keys[i][1] == 91 && strlen(keys[i]) == 3)) { // 'O'
+			// For some crazy reason xterm sends LeftArrow as [27,79,68]
+			// but Shift+LeftArrow as [27,91,49,59,50,68]
+			// the extra [59, 50] was expected but not the [79] -> [91,49]
+			// Basically seems to be sent in SS3 format in the first case
+			// but in CSI format in the second !
+			// http://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h2-PC-Style-Function-Keys
+			int keylen = strlen(keys[i]);
+			char k2[4]; // k2[keylen+1];
+			k2[0] = keys[i][0];
+			k2[1] = 91;
+			k2[2] = 49;
+
+			int a;
+			for (a = 2; a < keylen; a++) {
+				k2[a+1] = keys[i][a];
+			}
+
+			sprintf(desc, " k2 (%d): %d, %d, %d", (int)strlen(k2), k2[0], k2[1], k2[2]);
+			if (parse_meta_key(event, buf, k2)) {
+				if (buf[2] != 49) {
+					switch(buf[2]) {
+						case 66:
+						  event->key = TB_KEY_ARROW_DOWN;
+						  break;
+						case 67:
+							event->key = TB_KEY_ARROW_RIGHT;
+							break;
+						case 68:
+							event->key = TB_KEY_ARROW_LEFT;
+							break;
+						default:
+							break;
+					}
+					event->meta = 0;
+				} else {
+					event->key = 0xFFFF - i;
+				}
+
+				return strlen(k2) + 2;
+			}
+		}
 	}
 	return 0;
 }
@@ -166,6 +366,7 @@ static bool extract_event(struct tb_event *event, struct bytebuffer *inbuf, int
 		return false;
 
 	if (buf[0] == '\033') {
+
 		int n = parse_escape_seq(event, buf, len);
 		if (n != 0) {
 			bool success = true;
@@ -202,7 +403,7 @@ static bool extract_event(struct tb_event *event, struct bytebuffer *inbuf, int
 
 	// first of all check if it's a functional key
 	if ((unsigned char)buf[0] <= TB_KEY_SPACE ||
-	    (unsigned char)buf[0] == TB_KEY_BACKSPACE2)
+			(unsigned char)buf[0] == TB_KEY_BACKSPACE2)
 	{
 		// fill event, pop buffer, return success */
 		event->ch = 0;
diff --git a/src/term.inl b/src/term.inl
index d2ebaa2..23b8899 100644
--- a/src/term.inl
+++ b/src/term.inl
@@ -16,6 +16,8 @@ enum {
 	T_FUNCS_NUM,
 };
 
+char * term_name;
+
 #define ENTER_MOUSE_SEQ "\x1b[?1000h\x1b[?1002h\x1b[?1015h\x1b[?1006h"
 #define EXIT_MOUSE_SEQ "\x1b[?1006l\x1b[?1015l\x1b[?1002l\x1b[?1000l"
 
@@ -103,6 +105,7 @@ static int init_term_builtin(void)
 {
 	int i;
 	const char *term = getenv("TERM");
+	term_name = term;
 
 	if (term) {
 		for (i = 0; terms[i].name; i++) {
diff --git a/src/termbox.h b/src/termbox.h
index dc2d372..fcfa505 100644
--- a/src/termbox.h
+++ b/src/termbox.h
@@ -94,6 +94,17 @@ extern "C" {
 #define TB_KEY_BACKSPACE2       0x7F
 #define TB_KEY_CTRL_8           0x7F /* clash with 'BACKSPACE2' */
 
+enum {
+	TB_META_SHIFT = 2,
+	TB_META_ALT,
+	TB_META_ALTSHIFT,
+	TB_META_CTRL,
+	TB_META_CTRLSHIFT,
+	TB_META_ALTCTRL,
+	TB_META_ALTCTRLSHIFT,
+	TB_META_META
+};
+
 /* These are non-existing ones.
  *
  * #define TB_KEY_CTRL_1 clash with '1'
@@ -156,6 +167,7 @@ struct tb_event {
 	uint8_t mod; /* modifiers to either 'key' or 'ch' below */
 	uint16_t key; /* one of the TB_KEY_* constants */
 	uint32_t ch; /* unicode character */
+	uint8_t meta;
 	int32_t w;
 	int32_t h;
 	int32_t x;
